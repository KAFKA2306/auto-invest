#!/usr/bin/env tsx
import "dotenv/config";
import YahooFinance from "yahoo-finance2";
import path from "node:path";
import { writeJson, writeCsv, readCsv } from "./shared/io";
import { computeValuation } from "./valuation/engine";
import type { ValuationPayload } from "./valuation/types";

const yahooFinance = new YahooFinance();

const SYMBOL = "^NDX";
const PROXY = "QQQ";

const fetchHistory = async (symbol: string) => {
  const end = new Date();
  const start = new Date(end);
  start.setFullYear(start.getFullYear() - 15); 

  const queryOptions = { period1: start, period2: end, interval: "1d" as const };
  const result = await yahooFinance.historical(symbol, queryOptions);
  return result.map((r) => ({
    date: r.date.toISOString().split("T")[0],
    close: r.adjClose || r.close,
  }));
};

// Mock data for things we can't easily fetch without API keys or complex scraping in this minimal port
// In a real scenario, we'd hook up FRED API or similar.
const RISK_FREE_RATE_ANNUAL_CONST = 0.045; 
const GDP_GROWTH_CONST = 0.025; 

const main = async () => {
  console.log(`Fetching data for ${SYMBOL} and ${PROXY}...`);
  
  // Try fetching NDX, fallback to QQQ if needed (NDX often requires permissions or is delayed)
  let pricesRaw = [];
  try {
      pricesRaw = await fetchHistory(SYMBOL);
      if (pricesRaw.length === 0) throw new Error("Empty NDX");
  } catch {
      console.log("NDX fetch failed, using QQQ as proxy...");
      pricesRaw = await fetchHistory(PROXY);
  }

  // Load EPS data (generated by fetch_bottom_up.ts)
  const epsPath = path.join(process.cwd(), "public/data/bottom_up_eps.json");
  let epsData: any = {};
  try {
      const fs = await import("node:fs/promises");
      epsData = JSON.parse(await fs.readFile(epsPath, "utf-8"));
  } catch {
      console.warn("Could not load bottom_up_eps.json, using mock EPS");
  }

  // Construct daily series
  const dates = pricesRaw.map(p => p.date);
  const prices = pricesRaw.map(p => p.close);
  const rfAnnual = new Array(prices.length).fill(RISK_FREE_RATE_ANNUAL_CONST);
  const gdpGrowth = new Array(prices.length).fill(GDP_GROWTH_CONST);
  
  // Interpolate EPS
  // Simplified: Use the base_period EPS from the JSON for all dates, 
  // or linear interpolate if we had a series. 
  // The Python script loaded a CSV. We'll try to be smarter if we can, 
  // but for now let's use the latest EPS and project it backwards/forwards simply 
  // or just use a constant to prove the pipeline works.
  const latestEps = epsData.base_period?.eps ?? 600;
  const forwardEps = new Array(prices.length).fill(latestEps);
  const yoyEpsGrowth = new Array(prices.length).fill(0.10); // Mock 10% growth

  console.log("Computing valuation metrics...");
  const rows = computeValuation(dates, prices, rfAnnual, gdpGrowth, forwardEps, yoyEpsGrowth);
  
  // Filter out initial nulls/warmup
  const validRows = rows.filter(r => r.earnings_yield > 0 && r.forward_pe > 0);
  const latest = validRows[validRows.length - 1];

  const payload: ValuationPayload = {
    as_of: latest.date,
    source: "ts_valuation_model",
    latest: {
      forward_pe: Number(latest.forward_pe.toFixed(4)),
      forward_eps: Number(latest.forward_eps.toFixed(4)),
      earnings_yield: Number(latest.earnings_yield.toFixed(6)),
      earnings_yield_spread: Number(latest.earnings_yield_spread.toFixed(6)),
      yoy_eps_growth: Number(latest.yoy_eps_growth.toFixed(6)),
      implied_forward_pe_from_price: Number(latest.implied_forward_pe_from_price.toFixed(4)),
    },
    series: validRows.map(r => ({
        date: r.date,
        forward_pe: Number(r.forward_pe.toFixed(4)),
        forward_eps: Number(r.forward_eps.toFixed(4)),
        earnings_yield: Number(r.earnings_yield.toFixed(6)),
        earnings_yield_spread: Number(r.earnings_yield_spread.toFixed(6)),
        implied_forward_pe_from_price: Number(r.implied_forward_pe_from_price.toFixed(4)),
        price_index: Number(r.price_index.toFixed(4)),
    })),
    metadata: {
      generated_at: new Date().toISOString().replace("T", " ").replace(/\..+/, "Z"),
      rolling_window_days: 20,
      pe_clip: [2.0, 60.0],
      ref_pe: 32.5,
    },
  };

  const dataDir = path.join(process.cwd(), "public/data");
  await writeJson(path.join(dataDir, "valuation.json"), payload);
  
  // Save CSV for debugging
  await writeCsv(path.join(process.cwd(), "data/processed/valuation_ts.csv"), validRows);
  
  console.log(`Saved valuation.json (as_of=${payload.as_of}, rows=${validRows.length})`);
};

main().catch(console.error);
